#include "dataexchange.hpp"
#include "base58.hpp"

using namespace std;
void dataexchange::removemarket(account_name owner, uint64_t marketid){
    //only the market owner can create a market
    require_auth(owner);

    auto iter = _markets.find(marketid);
    eosio_assert(iter != _markets.end(), "market not have been created yet");
    eosio_assert(iter->mowner == owner , "have no permission to this market");
    eosio_assert(hasorder_bymarketid(marketid) == false, "market can't be removed because it still has opening orders");
    
    _markets.erase(iter);
}


void dataexchange::createmarket(account_name owner, uint64_t type, string desp){
    //only the contract owner can create a market
    require_auth(_self);

    eosio_assert(desp.length() < 30, "market description should be less than 30 characters");
    eosio_assert(hasmarket_byaccountname(owner) == false, "an account can only create only one market now");
    eosio_assert((type > typestart && type < typeend), "out of market type");

    auto iter = _availableid.begin();
    uint64_t id = 0;
    if (iter == _availableid.end()) {
        _availableid.emplace( _self, [&]( auto& row) {
            row.availmarketid = id;
            row.availorderid = 0;
            row.padding = 0;
        });
    } else {
        id = iter->availmarketid + 1;
        _availableid.modify( iter, 0, [&]( auto& row) {
            row.availmarketid = id;
        });
    }

    _markets.emplace( _self, [&]( auto& row) {
        row.marketid = id;
        row.mowner = owner;
        row.mtype = type;
        row.mdesp = desp;
    });
}

void dataexchange::createorder(account_name seller, uint64_t marketid, asset& price) {
    require_auth(seller);

    eosio_assert(hasmareket_byid(marketid) == true, "no such market");

    auto iter = _availableid.begin();
    eosio_assert(iter != _availableid.end(), "availableid should have been initialized");

    uint64_t id = 0;
    id = iter->availorderid + 1;
    _availableid.modify( iter, 0, [&]( auto& row) {
        row.availorderid = id;
    });

    auto miter = _markets.find(marketid);
    eosio_assert(miter->mowner != seller, "please don't sell on your own market");
    ordertable orders(_self, miter->mowner); 

    // we can only put it to the contract owner scope
    orders.emplace(seller, [&]( auto& order) {
        order.orderid = id;
        order.seller = seller;
        order.marketid = marketid;
        order.price = price;
        order.orderstate = orderstate_start;
        order.datahash = "";
    });

   //reg seller to accounts table 
   auto itr = _accounts.find(seller);
   if( itr == _accounts.end() ) {
      itr = _accounts.emplace(_self, [&](auto& acnt){
         acnt.owner = seller;
      });
   }
}

void dataexchange::cancelorder(account_name seller, account_name owner, uint64_t orderid) {
    require_auth(seller);

    ordertable orders(_self, owner);
    auto iter = orders.find(orderid);

    eosio_assert(iter != orders.end() , "no such order");
    eosio_assert(iter->seller == seller, "order doesn't belong to you");
    eosio_assert(iter->orderstate != orderstate_finished, "only unfinished orders can be canceled");
    orders.erase(iter);
}

void dataexchange::eraseorder(account_name seller, account_name owner, uint64_t orderid) {
    require_auth(seller);

    ordertable orders(_self, owner);
    auto iter = orders.find(orderid);

    eosio_assert(iter != orders.end() , "no such order");
    eosio_assert(iter->seller == seller, "order doesn't belong to you");
    eosio_assert(iter->orderstate == orderstate_finished, "only finished orders can be erased");
    orders.erase(iter);
}

//owner is the market owner, not the seller, seller is stored in struct order.
void dataexchange::tryfillorder(account_name buyer, account_name owner, uint64_t orderid) {
    require_auth(buyer);

    ordertable orders(_self, owner);
    auto iter = orders.find(orderid);

    eosio_assert(iter != orders.end() , "no such order");

    // buyer costs tokens
    auto buyeritr = _accounts.find(buyer);
    eosio_assert(buyeritr != _accounts.end() , "buyer should have deposit token");
    _accounts.modify( buyeritr, 0, [&]( auto& acnt ) {
       acnt.asset_balance -= iter->price;
    });

    orders.modify( iter, 0, [&]( auto& order) {
       order.buyer = buyer;
       order.orderstate = orderstate_waitinghash;
    });

}

//owner is the order seller, datahash is generated by the buyers public key encrypted user's data.
void dataexchange::finishorder(account_name seller, account_name owner, uint64_t orderid, string datahash) {
    require_auth(seller);

    ordertable orders(_self, owner);
    auto iter = orders.find(orderid);

    eosio_assert(iter != orders.end() , "no such order");
    eosio_assert(iter->orderstate == orderstate_waitinghash, "order state is not orderstate_waitinghash");

    orders.modify( iter, 0, [&]( auto& order) {
       order.datahash = datahash;
       order.orderstate = orderstate_finished;
    });

    // add token to seller's account
    auto selleriter = _accounts.find(iter->seller);
    eosio_assert(selleriter != _accounts.end() , "seller should have an account");
    _accounts.modify( selleriter, 0, [&]( auto& acnt ) {
       acnt.asset_balance += iter->price;
    });
}

void dataexchange::deposit(account_name from, asset& quantity ) {
   
   eosio_assert( quantity.is_valid(), "invalid quantity" );
   eosio_assert( quantity.amount > 0, "must deposit positive quantity" );

   auto itr = _accounts.find(from);
   if( itr == _accounts.end() ) {
      itr = _accounts.emplace(_self, [&](auto& acnt){
         acnt.owner = from;
      });
   }

   _accounts.modify( itr, 0, [&]( auto& acnt ) {
       acnt.asset_balance += quantity;
   });

   //make sure contract xingyitoken have been deployed to blockchain to make it runnable
   //xingyitoken is our own token, its symblo is SYS
   action(
      permission_level{ from, N(active) },
      N(xingyitoken), N(transfer),
      std::make_tuple(from, _self, quantity, std::string("deposit token"))
   ).send();
}

void dataexchange::withdraw(account_name owner, asset& quantity ) {
   require_auth( owner );

   eosio_assert( quantity.is_valid(), "invalid quantity" );
   eosio_assert( quantity.amount > 0, "must withdraw positive quantity" );

   auto itr = _accounts.find( owner );
   eosio_assert(itr != _accounts.end(), "account has no fund, can't withdraw");

   _accounts.modify( itr, 0, [&]( auto& acnt ) {
      eosio_assert( acnt.asset_balance >= quantity, "insufficient balance" );
      acnt.asset_balance -= quantity;
   });

   //make sure contract xingyitoken have been deployed to blockchain to make it runnable
   //xingyitoken is our own token, its symblo is SYS
   action(
      permission_level{ _self, N(active) },
      N(xingyitoken), N(transfer),
      std::make_tuple(_self, owner, quantity, std::string("withdraw token"))
   ).send();

   // erase account when no more fund to free memory 
   if( itr->asset_balance.amount == 0 && itr->pkey.length() == 0) {
      _accounts.erase(itr);
   }
}

void dataexchange::regpkey(account_name owner, string pkey) {
   require_auth( owner );

   pkey.erase(pkey.begin(), find_if(pkey.begin(), pkey.end(), [](int ch) {
       return !isspace(ch);
   }));
   pkey.erase(find_if(pkey.rbegin(), pkey.rend(), [](int ch) {
       return !isspace(ch);
   }).base(), pkey.end());

   eosio_assert(pkey.length() == 53, "Length of public key should be 53");
   string pubkey_prefix("EOS");
   auto result = mismatch(pubkey_prefix.begin(), pubkey_prefix.end(), pkey.begin());
   eosio_assert(result.first == pubkey_prefix.end(), "Public key should be prefix with EOS");

   auto base58substr = pkey.substr(pubkey_prefix.length());
   vector<unsigned char> vch;
   //(fixme)decode_base58 can be very time-consuming, must remove it in the future.
   eosio_assert(decode_base58(base58substr, vch), "Decode public failed");
   eosio_assert(vch.size() == 37, "Invalid public key: invalid base58 length");

   array<unsigned char,33> pubkey_data;
   copy_n(vch.begin(), 33, pubkey_data.begin());

   checksum160 check_pubkey;
   ripemd160(reinterpret_cast<char *>(pubkey_data.data()), 33, &check_pubkey);
   eosio_assert(memcmp(&check_pubkey.hash, &vch.end()[-4], 4) == 0, "Invalid public key: invalid checksum");

   auto itr = _accounts.find( owner );
   if( itr == _accounts.end() ) {
      itr = _accounts.emplace(_self, [&](auto& acnt){
         acnt.owner = owner;
      });
   }

   _accounts.modify( itr, 0, [&]( auto& acnt ) {
      acnt.pkey = pkey;
   });
}

void dataexchange::deregpkey(account_name owner) {
   require_auth( owner );

   auto itr = _accounts.find( owner );
   eosio_assert(itr != _accounts.end(), "account not registered yet");

   if (itr->asset_balance.amount > 0) {
       _accounts.modify( itr, 0, [&]( auto& acnt ) {
          acnt.pkey = "";
       });
   } else {
         _accounts.erase(itr);
   }
}

